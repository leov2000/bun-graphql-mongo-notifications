// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.4
// source: notifications.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { DoubleValue, Int32Value, StringValue } from "./google/protobuf/wrappers";

export const protobufPackage = "notification";

/** Request/Response message types */
export interface GetUserNotificationsRequest {
  user: string;
  sleep: boolean;
}

export interface GetGroupMembersRequest {
  groupName: string;
}

export interface GetGroupNotificationsRequest {
  groupName: string;
  tags: string[];
}

export interface SendNotificationRequest {
  toUser: string;
  fromUser: string;
  payload: string;
  ttl: TTLOptions | undefined;
}

export interface SendGroupNotificationRequest {
  groupName: string;
  fromUser: string;
  payload: string;
  tags: string[];
  ttl: TTLOptions | undefined;
}

export interface GroupMemberRequest {
  user: string;
  groupName: string;
}

export interface CreateGroupRequest {
  users: string[];
  groupName: string;
}

export interface SleepNotificationRequest {
  notificationId: string;
  sleep: boolean;
}

export interface UserRequest {
  user: string;
}

export interface GroupNotificationsRequest {
  groupName: string;
  tags: string[];
}

/** Data types */
export interface Notification {
  _id: string;
  user: string | undefined;
  fromUser: string;
  groupName: string | undefined;
  payload: string;
  sleep: boolean;
  tags: string[];
  expireAt: number | undefined;
  createdAt: string;
}

export interface TTLOptions {
  mins: number | undefined;
  hours: number | undefined;
  days: number | undefined;
}

export interface UserGroup {
  users: string[];
}

export interface NotificationList {
  notifications: Notification[];
}

export interface UserGroupList {
  userGroups: UserGroup[];
}

export interface BoolResponse {
  success: boolean;
  message: string;
}

function createBaseGetUserNotificationsRequest(): GetUserNotificationsRequest {
  return { user: "", sleep: false };
}

export const GetUserNotificationsRequest: MessageFns<GetUserNotificationsRequest> = {
  encode(message: GetUserNotificationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    if (message.sleep !== false) {
      writer.uint32(16).bool(message.sleep);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserNotificationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserNotificationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sleep = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserNotificationsRequest {
    return {
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      sleep: isSet(object.sleep) ? globalThis.Boolean(object.sleep) : false,
    };
  },

  toJSON(message: GetUserNotificationsRequest): unknown {
    const obj: any = {};
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.sleep !== false) {
      obj.sleep = message.sleep;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserNotificationsRequest>, I>>(base?: I): GetUserNotificationsRequest {
    return GetUserNotificationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserNotificationsRequest>, I>>(object: I): GetUserNotificationsRequest {
    const message = createBaseGetUserNotificationsRequest();
    message.user = object.user ?? "";
    message.sleep = object.sleep ?? false;
    return message;
  },
};

function createBaseGetGroupMembersRequest(): GetGroupMembersRequest {
  return { groupName: "" };
}

export const GetGroupMembersRequest: MessageFns<GetGroupMembersRequest> = {
  encode(message: GetGroupMembersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupName !== "") {
      writer.uint32(10).string(message.groupName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupMembersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupMembersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupMembersRequest {
    return { groupName: isSet(object.groupName) ? globalThis.String(object.groupName) : "" };
  },

  toJSON(message: GetGroupMembersRequest): unknown {
    const obj: any = {};
    if (message.groupName !== "") {
      obj.groupName = message.groupName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupMembersRequest>, I>>(base?: I): GetGroupMembersRequest {
    return GetGroupMembersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupMembersRequest>, I>>(object: I): GetGroupMembersRequest {
    const message = createBaseGetGroupMembersRequest();
    message.groupName = object.groupName ?? "";
    return message;
  },
};

function createBaseGetGroupNotificationsRequest(): GetGroupNotificationsRequest {
  return { groupName: "", tags: [] };
}

export const GetGroupNotificationsRequest: MessageFns<GetGroupNotificationsRequest> = {
  encode(message: GetGroupNotificationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupName !== "") {
      writer.uint32(10).string(message.groupName);
    }
    for (const v of message.tags) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupNotificationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupNotificationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupNotificationsRequest {
    return {
      groupName: isSet(object.groupName) ? globalThis.String(object.groupName) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetGroupNotificationsRequest): unknown {
    const obj: any = {};
    if (message.groupName !== "") {
      obj.groupName = message.groupName;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupNotificationsRequest>, I>>(base?: I): GetGroupNotificationsRequest {
    return GetGroupNotificationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupNotificationsRequest>, I>>(object: I): GetGroupNotificationsRequest {
    const message = createBaseGetGroupNotificationsRequest();
    message.groupName = object.groupName ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseSendNotificationRequest(): SendNotificationRequest {
  return { toUser: "", fromUser: "", payload: "", ttl: undefined };
}

export const SendNotificationRequest: MessageFns<SendNotificationRequest> = {
  encode(message: SendNotificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUser !== "") {
      writer.uint32(10).string(message.toUser);
    }
    if (message.fromUser !== "") {
      writer.uint32(18).string(message.fromUser);
    }
    if (message.payload !== "") {
      writer.uint32(26).string(message.payload);
    }
    if (message.ttl !== undefined) {
      TTLOptions.encode(message.ttl, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendNotificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toUser = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromUser = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ttl = TTLOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendNotificationRequest {
    return {
      toUser: isSet(object.toUser) ? globalThis.String(object.toUser) : "",
      fromUser: isSet(object.fromUser) ? globalThis.String(object.fromUser) : "",
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      ttl: isSet(object.ttl) ? TTLOptions.fromJSON(object.ttl) : undefined,
    };
  },

  toJSON(message: SendNotificationRequest): unknown {
    const obj: any = {};
    if (message.toUser !== "") {
      obj.toUser = message.toUser;
    }
    if (message.fromUser !== "") {
      obj.fromUser = message.fromUser;
    }
    if (message.payload !== "") {
      obj.payload = message.payload;
    }
    if (message.ttl !== undefined) {
      obj.ttl = TTLOptions.toJSON(message.ttl);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendNotificationRequest>, I>>(base?: I): SendNotificationRequest {
    return SendNotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendNotificationRequest>, I>>(object: I): SendNotificationRequest {
    const message = createBaseSendNotificationRequest();
    message.toUser = object.toUser ?? "";
    message.fromUser = object.fromUser ?? "";
    message.payload = object.payload ?? "";
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? TTLOptions.fromPartial(object.ttl) : undefined;
    return message;
  },
};

function createBaseSendGroupNotificationRequest(): SendGroupNotificationRequest {
  return { groupName: "", fromUser: "", payload: "", tags: [], ttl: undefined };
}

export const SendGroupNotificationRequest: MessageFns<SendGroupNotificationRequest> = {
  encode(message: SendGroupNotificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupName !== "") {
      writer.uint32(10).string(message.groupName);
    }
    if (message.fromUser !== "") {
      writer.uint32(18).string(message.fromUser);
    }
    if (message.payload !== "") {
      writer.uint32(26).string(message.payload);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    if (message.ttl !== undefined) {
      TTLOptions.encode(message.ttl, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendGroupNotificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendGroupNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromUser = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ttl = TTLOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendGroupNotificationRequest {
    return {
      groupName: isSet(object.groupName) ? globalThis.String(object.groupName) : "",
      fromUser: isSet(object.fromUser) ? globalThis.String(object.fromUser) : "",
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      ttl: isSet(object.ttl) ? TTLOptions.fromJSON(object.ttl) : undefined,
    };
  },

  toJSON(message: SendGroupNotificationRequest): unknown {
    const obj: any = {};
    if (message.groupName !== "") {
      obj.groupName = message.groupName;
    }
    if (message.fromUser !== "") {
      obj.fromUser = message.fromUser;
    }
    if (message.payload !== "") {
      obj.payload = message.payload;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.ttl !== undefined) {
      obj.ttl = TTLOptions.toJSON(message.ttl);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendGroupNotificationRequest>, I>>(base?: I): SendGroupNotificationRequest {
    return SendGroupNotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendGroupNotificationRequest>, I>>(object: I): SendGroupNotificationRequest {
    const message = createBaseSendGroupNotificationRequest();
    message.groupName = object.groupName ?? "";
    message.fromUser = object.fromUser ?? "";
    message.payload = object.payload ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? TTLOptions.fromPartial(object.ttl) : undefined;
    return message;
  },
};

function createBaseGroupMemberRequest(): GroupMemberRequest {
  return { user: "", groupName: "" };
}

export const GroupMemberRequest: MessageFns<GroupMemberRequest> = {
  encode(message: GroupMemberRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    if (message.groupName !== "") {
      writer.uint32(18).string(message.groupName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupMemberRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMemberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMemberRequest {
    return {
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      groupName: isSet(object.groupName) ? globalThis.String(object.groupName) : "",
    };
  },

  toJSON(message: GroupMemberRequest): unknown {
    const obj: any = {};
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.groupName !== "") {
      obj.groupName = message.groupName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMemberRequest>, I>>(base?: I): GroupMemberRequest {
    return GroupMemberRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMemberRequest>, I>>(object: I): GroupMemberRequest {
    const message = createBaseGroupMemberRequest();
    message.user = object.user ?? "";
    message.groupName = object.groupName ?? "";
    return message;
  },
};

function createBaseCreateGroupRequest(): CreateGroupRequest {
  return { users: [], groupName: "" };
}

export const CreateGroupRequest: MessageFns<CreateGroupRequest> = {
  encode(message: CreateGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      writer.uint32(10).string(v!);
    }
    if (message.groupName !== "") {
      writer.uint32(18).string(message.groupName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGroupRequest {
    return {
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => globalThis.String(e)) : [],
      groupName: isSet(object.groupName) ? globalThis.String(object.groupName) : "",
    };
  },

  toJSON(message: CreateGroupRequest): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users;
    }
    if (message.groupName !== "") {
      obj.groupName = message.groupName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGroupRequest>, I>>(base?: I): CreateGroupRequest {
    return CreateGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGroupRequest>, I>>(object: I): CreateGroupRequest {
    const message = createBaseCreateGroupRequest();
    message.users = object.users?.map((e) => e) || [];
    message.groupName = object.groupName ?? "";
    return message;
  },
};

function createBaseSleepNotificationRequest(): SleepNotificationRequest {
  return { notificationId: "", sleep: false };
}

export const SleepNotificationRequest: MessageFns<SleepNotificationRequest> = {
  encode(message: SleepNotificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notificationId !== "") {
      writer.uint32(10).string(message.notificationId);
    }
    if (message.sleep !== false) {
      writer.uint32(16).bool(message.sleep);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SleepNotificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSleepNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notificationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sleep = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SleepNotificationRequest {
    return {
      notificationId: isSet(object.notificationId) ? globalThis.String(object.notificationId) : "",
      sleep: isSet(object.sleep) ? globalThis.Boolean(object.sleep) : false,
    };
  },

  toJSON(message: SleepNotificationRequest): unknown {
    const obj: any = {};
    if (message.notificationId !== "") {
      obj.notificationId = message.notificationId;
    }
    if (message.sleep !== false) {
      obj.sleep = message.sleep;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SleepNotificationRequest>, I>>(base?: I): SleepNotificationRequest {
    return SleepNotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SleepNotificationRequest>, I>>(object: I): SleepNotificationRequest {
    const message = createBaseSleepNotificationRequest();
    message.notificationId = object.notificationId ?? "";
    message.sleep = object.sleep ?? false;
    return message;
  },
};

function createBaseUserRequest(): UserRequest {
  return { user: "" };
}

export const UserRequest: MessageFns<UserRequest> = {
  encode(message: UserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserRequest {
    return { user: isSet(object.user) ? globalThis.String(object.user) : "" };
  },

  toJSON(message: UserRequest): unknown {
    const obj: any = {};
    if (message.user !== "") {
      obj.user = message.user;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserRequest>, I>>(base?: I): UserRequest {
    return UserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserRequest>, I>>(object: I): UserRequest {
    const message = createBaseUserRequest();
    message.user = object.user ?? "";
    return message;
  },
};

function createBaseGroupNotificationsRequest(): GroupNotificationsRequest {
  return { groupName: "", tags: [] };
}

export const GroupNotificationsRequest: MessageFns<GroupNotificationsRequest> = {
  encode(message: GroupNotificationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupName !== "") {
      writer.uint32(10).string(message.groupName);
    }
    for (const v of message.tags) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupNotificationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupNotificationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupNotificationsRequest {
    return {
      groupName: isSet(object.groupName) ? globalThis.String(object.groupName) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GroupNotificationsRequest): unknown {
    const obj: any = {};
    if (message.groupName !== "") {
      obj.groupName = message.groupName;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupNotificationsRequest>, I>>(base?: I): GroupNotificationsRequest {
    return GroupNotificationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupNotificationsRequest>, I>>(object: I): GroupNotificationsRequest {
    const message = createBaseGroupNotificationsRequest();
    message.groupName = object.groupName ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseNotification(): Notification {
  return {
    _id: "",
    user: undefined,
    fromUser: "",
    groupName: undefined,
    payload: "",
    sleep: false,
    tags: [],
    expireAt: undefined,
    createdAt: "",
  };
}

export const Notification: MessageFns<Notification> = {
  encode(message: Notification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message._id !== "") {
      writer.uint32(10).string(message._id);
    }
    if (message.user !== undefined) {
      StringValue.encode({ value: message.user! }, writer.uint32(18).fork()).join();
    }
    if (message.fromUser !== "") {
      writer.uint32(26).string(message.fromUser);
    }
    if (message.groupName !== undefined) {
      StringValue.encode({ value: message.groupName! }, writer.uint32(34).fork()).join();
    }
    if (message.payload !== "") {
      writer.uint32(42).string(message.payload);
    }
    if (message.sleep !== false) {
      writer.uint32(48).bool(message.sleep);
    }
    for (const v of message.tags) {
      writer.uint32(58).string(v!);
    }
    if (message.expireAt !== undefined) {
      DoubleValue.encode({ value: message.expireAt! }, writer.uint32(66).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Notification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message._id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromUser = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sleep = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expireAt = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Notification {
    return {
      _id: isSet(object._id) ? globalThis.String(object._id) : "",
      user: isSet(object.user) ? String(object.user) : undefined,
      fromUser: isSet(object.fromUser) ? globalThis.String(object.fromUser) : "",
      groupName: isSet(object.groupName) ? String(object.groupName) : undefined,
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      sleep: isSet(object.sleep) ? globalThis.Boolean(object.sleep) : false,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      expireAt: isSet(object.expireAt) ? Number(object.expireAt) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
    };
  },

  toJSON(message: Notification): unknown {
    const obj: any = {};
    if (message._id !== "") {
      obj._id = message._id;
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.fromUser !== "") {
      obj.fromUser = message.fromUser;
    }
    if (message.groupName !== undefined) {
      obj.groupName = message.groupName;
    }
    if (message.payload !== "") {
      obj.payload = message.payload;
    }
    if (message.sleep !== false) {
      obj.sleep = message.sleep;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.expireAt !== undefined) {
      obj.expireAt = message.expireAt;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Notification>, I>>(base?: I): Notification {
    return Notification.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Notification>, I>>(object: I): Notification {
    const message = createBaseNotification();
    message._id = object._id ?? "";
    message.user = object.user ?? undefined;
    message.fromUser = object.fromUser ?? "";
    message.groupName = object.groupName ?? undefined;
    message.payload = object.payload ?? "";
    message.sleep = object.sleep ?? false;
    message.tags = object.tags?.map((e) => e) || [];
    message.expireAt = object.expireAt ?? undefined;
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseTTLOptions(): TTLOptions {
  return { mins: undefined, hours: undefined, days: undefined };
}

export const TTLOptions: MessageFns<TTLOptions> = {
  encode(message: TTLOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mins !== undefined) {
      Int32Value.encode({ value: message.mins! }, writer.uint32(10).fork()).join();
    }
    if (message.hours !== undefined) {
      Int32Value.encode({ value: message.hours! }, writer.uint32(18).fork()).join();
    }
    if (message.days !== undefined) {
      Int32Value.encode({ value: message.days! }, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TTLOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTTLOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mins = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hours = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.days = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TTLOptions {
    return {
      mins: isSet(object.mins) ? Number(object.mins) : undefined,
      hours: isSet(object.hours) ? Number(object.hours) : undefined,
      days: isSet(object.days) ? Number(object.days) : undefined,
    };
  },

  toJSON(message: TTLOptions): unknown {
    const obj: any = {};
    if (message.mins !== undefined) {
      obj.mins = message.mins;
    }
    if (message.hours !== undefined) {
      obj.hours = message.hours;
    }
    if (message.days !== undefined) {
      obj.days = message.days;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TTLOptions>, I>>(base?: I): TTLOptions {
    return TTLOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TTLOptions>, I>>(object: I): TTLOptions {
    const message = createBaseTTLOptions();
    message.mins = object.mins ?? undefined;
    message.hours = object.hours ?? undefined;
    message.days = object.days ?? undefined;
    return message;
  },
};

function createBaseUserGroup(): UserGroup {
  return { users: [] };
}

export const UserGroup: MessageFns<UserGroup> = {
  encode(message: UserGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserGroup {
    return { users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: UserGroup): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserGroup>, I>>(base?: I): UserGroup {
    return UserGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserGroup>, I>>(object: I): UserGroup {
    const message = createBaseUserGroup();
    message.users = object.users?.map((e) => e) || [];
    return message;
  },
};

function createBaseNotificationList(): NotificationList {
  return { notifications: [] };
}

export const NotificationList: MessageFns<NotificationList> = {
  encode(message: NotificationList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.notifications) {
      Notification.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notifications.push(Notification.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationList {
    return {
      notifications: globalThis.Array.isArray(object?.notifications)
        ? object.notifications.map((e: any) => Notification.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NotificationList): unknown {
    const obj: any = {};
    if (message.notifications?.length) {
      obj.notifications = message.notifications.map((e) => Notification.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationList>, I>>(base?: I): NotificationList {
    return NotificationList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationList>, I>>(object: I): NotificationList {
    const message = createBaseNotificationList();
    message.notifications = object.notifications?.map((e) => Notification.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserGroupList(): UserGroupList {
  return { userGroups: [] };
}

export const UserGroupList: MessageFns<UserGroupList> = {
  encode(message: UserGroupList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userGroups) {
      UserGroup.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserGroupList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserGroupList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userGroups.push(UserGroup.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserGroupList {
    return {
      userGroups: globalThis.Array.isArray(object?.userGroups)
        ? object.userGroups.map((e: any) => UserGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserGroupList): unknown {
    const obj: any = {};
    if (message.userGroups?.length) {
      obj.userGroups = message.userGroups.map((e) => UserGroup.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserGroupList>, I>>(base?: I): UserGroupList {
    return UserGroupList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserGroupList>, I>>(object: I): UserGroupList {
    const message = createBaseUserGroupList();
    message.userGroups = object.userGroups?.map((e) => UserGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBoolResponse(): BoolResponse {
  return { success: false, message: "" };
}

export const BoolResponse: MessageFns<BoolResponse> = {
  encode(message: BoolResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoolResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoolResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: BoolResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BoolResponse>, I>>(base?: I): BoolResponse {
    return BoolResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BoolResponse>, I>>(object: I): BoolResponse {
    const message = createBaseBoolResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

export type NotificationServiceService = typeof NotificationServiceService;
export const NotificationServiceService = {
  getUserNotifications: {
    path: "/notification.NotificationService/GetUserNotifications",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserNotificationsRequest) =>
      Buffer.from(GetUserNotificationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUserNotificationsRequest.decode(value),
    responseSerialize: (value: NotificationList) => Buffer.from(NotificationList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NotificationList.decode(value),
  },
  getGroupMembers: {
    path: "/notification.NotificationService/GetGroupMembers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGroupMembersRequest) => Buffer.from(GetGroupMembersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetGroupMembersRequest.decode(value),
    responseSerialize: (value: UserGroupList) => Buffer.from(UserGroupList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UserGroupList.decode(value),
  },
  getGroupNotifications: {
    path: "/notification.NotificationService/GetGroupNotifications",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGroupNotificationsRequest) =>
      Buffer.from(GetGroupNotificationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetGroupNotificationsRequest.decode(value),
    responseSerialize: (value: NotificationList) => Buffer.from(NotificationList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NotificationList.decode(value),
  },
  sendNotification: {
    path: "/notification.NotificationService/SendNotification",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendNotificationRequest) => Buffer.from(SendNotificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendNotificationRequest.decode(value),
    responseSerialize: (value: BoolResponse) => Buffer.from(BoolResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BoolResponse.decode(value),
  },
  sendGroupNotification: {
    path: "/notification.NotificationService/SendGroupNotification",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendGroupNotificationRequest) =>
      Buffer.from(SendGroupNotificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendGroupNotificationRequest.decode(value),
    responseSerialize: (value: BoolResponse) => Buffer.from(BoolResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BoolResponse.decode(value),
  },
  addGroupMember: {
    path: "/notification.NotificationService/AddGroupMember",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GroupMemberRequest) => Buffer.from(GroupMemberRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GroupMemberRequest.decode(value),
    responseSerialize: (value: BoolResponse) => Buffer.from(BoolResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BoolResponse.decode(value),
  },
  createGroup: {
    path: "/notification.NotificationService/CreateGroup",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateGroupRequest) => Buffer.from(CreateGroupRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateGroupRequest.decode(value),
    responseSerialize: (value: BoolResponse) => Buffer.from(BoolResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BoolResponse.decode(value),
  },
  removeGroupMember: {
    path: "/notification.NotificationService/RemoveGroupMember",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GroupMemberRequest) => Buffer.from(GroupMemberRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GroupMemberRequest.decode(value),
    responseSerialize: (value: BoolResponse) => Buffer.from(BoolResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BoolResponse.decode(value),
  },
  sleepNotification: {
    path: "/notification.NotificationService/SleepNotification",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SleepNotificationRequest) => Buffer.from(SleepNotificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SleepNotificationRequest.decode(value),
    responseSerialize: (value: BoolResponse) => Buffer.from(BoolResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BoolResponse.decode(value),
  },
  subscribeToUserNotifications: {
    path: "/notification.NotificationService/SubscribeToUserNotifications",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: UserRequest) => Buffer.from(UserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UserRequest.decode(value),
    responseSerialize: (value: Notification) => Buffer.from(Notification.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Notification.decode(value),
  },
  subscribeToGroupNotifications: {
    path: "/notification.NotificationService/SubscribeToGroupNotifications",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: GroupNotificationsRequest) =>
      Buffer.from(GroupNotificationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GroupNotificationsRequest.decode(value),
    responseSerialize: (value: Notification) => Buffer.from(Notification.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Notification.decode(value),
  },
} as const;

export interface NotificationServiceServer extends UntypedServiceImplementation {
  getUserNotifications: handleUnaryCall<GetUserNotificationsRequest, NotificationList>;
  getGroupMembers: handleUnaryCall<GetGroupMembersRequest, UserGroupList>;
  getGroupNotifications: handleUnaryCall<GetGroupNotificationsRequest, NotificationList>;
  sendNotification: handleUnaryCall<SendNotificationRequest, BoolResponse>;
  sendGroupNotification: handleUnaryCall<SendGroupNotificationRequest, BoolResponse>;
  addGroupMember: handleUnaryCall<GroupMemberRequest, BoolResponse>;
  createGroup: handleUnaryCall<CreateGroupRequest, BoolResponse>;
  removeGroupMember: handleUnaryCall<GroupMemberRequest, BoolResponse>;
  sleepNotification: handleUnaryCall<SleepNotificationRequest, BoolResponse>;
  subscribeToUserNotifications: handleServerStreamingCall<UserRequest, Notification>;
  subscribeToGroupNotifications: handleServerStreamingCall<GroupNotificationsRequest, Notification>;
}

export interface NotificationServiceClient extends Client {
  getUserNotifications(
    request: GetUserNotificationsRequest,
    callback: (error: ServiceError | null, response: NotificationList) => void,
  ): ClientUnaryCall;
  getUserNotifications(
    request: GetUserNotificationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NotificationList) => void,
  ): ClientUnaryCall;
  getUserNotifications(
    request: GetUserNotificationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NotificationList) => void,
  ): ClientUnaryCall;
  getGroupMembers(
    request: GetGroupMembersRequest,
    callback: (error: ServiceError | null, response: UserGroupList) => void,
  ): ClientUnaryCall;
  getGroupMembers(
    request: GetGroupMembersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UserGroupList) => void,
  ): ClientUnaryCall;
  getGroupMembers(
    request: GetGroupMembersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UserGroupList) => void,
  ): ClientUnaryCall;
  getGroupNotifications(
    request: GetGroupNotificationsRequest,
    callback: (error: ServiceError | null, response: NotificationList) => void,
  ): ClientUnaryCall;
  getGroupNotifications(
    request: GetGroupNotificationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NotificationList) => void,
  ): ClientUnaryCall;
  getGroupNotifications(
    request: GetGroupNotificationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NotificationList) => void,
  ): ClientUnaryCall;
  sendNotification(
    request: SendNotificationRequest,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  sendNotification(
    request: SendNotificationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  sendNotification(
    request: SendNotificationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  sendGroupNotification(
    request: SendGroupNotificationRequest,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  sendGroupNotification(
    request: SendGroupNotificationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  sendGroupNotification(
    request: SendGroupNotificationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  addGroupMember(
    request: GroupMemberRequest,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  addGroupMember(
    request: GroupMemberRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  addGroupMember(
    request: GroupMemberRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  createGroup(
    request: CreateGroupRequest,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  createGroup(
    request: CreateGroupRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  createGroup(
    request: CreateGroupRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  removeGroupMember(
    request: GroupMemberRequest,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  removeGroupMember(
    request: GroupMemberRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  removeGroupMember(
    request: GroupMemberRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  sleepNotification(
    request: SleepNotificationRequest,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  sleepNotification(
    request: SleepNotificationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  sleepNotification(
    request: SleepNotificationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BoolResponse) => void,
  ): ClientUnaryCall;
  subscribeToUserNotifications(
    request: UserRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<Notification>;
  subscribeToUserNotifications(
    request: UserRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<Notification>;
  subscribeToGroupNotifications(
    request: GroupNotificationsRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<Notification>;
  subscribeToGroupNotifications(
    request: GroupNotificationsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<Notification>;
}

export const NotificationServiceClient = makeGenericClientConstructor(
  NotificationServiceService,
  "notification.NotificationService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): NotificationServiceClient;
  service: typeof NotificationServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
